import type {
  StorageActionWriter as ConvexStorageActionWriter,
  StorageReader as ConvexStorageReader,
  StorageWriter as ConvexStorageWriter,
} from "convex/server"
import type {GenericId} from "convex/values"

import {Effect as E} from "effect"

import {FileNotFoundError} from "./error"

/**
 * An interface to read files from storage within Convex query functions.
 *
 * This Effect-based wrapper provides type-safe storage operations that return
 * Effects with structured error handling instead of null values.
 */
export class StorageReader {
  convexStorage: ConvexStorageReader

  constructor(convexStorage: ConvexStorageReader) {
    this.convexStorage = convexStorage
  }

  /**
   * Get the URL for a file in storage by its `Id<"_storage">`.
   *
   * The GET response includes a standard HTTP Digest header with a sha256 checksum.
   *
   * @param storageId - The `Id<"_storage">` of the file to fetch from Convex storage.
   * @returns An Effect that yields the file URL if the file exists, or fails
   * with FileNotFoundError if the file is not found.
   */
  getUrl(storageId: GenericId<"_storage">): E.Effect<string, FileNotFoundError, never> {
    return E.promise(async () => this.convexStorage.getUrl(storageId)).pipe(
      E.flatMap((url) => {
        if (url) {
          return E.succeed(url)
        }

        return E.fail(new FileNotFoundError())
      }),
    )
  }
}

/**
 * An interface to write files to storage within Convex mutation functions.
 *
 * Extends StorageReader with Effect-based write operations for composable
 * file storage management.
 */
export class StorageWriter extends StorageReader {
  override convexStorage: ConvexStorageWriter

  constructor(convexStorage: ConvexStorageWriter) {
    super(convexStorage)
    this.convexStorage = convexStorage
  }

  /**
   * Fetch a short-lived URL for uploading a file into storage.
   *
   * Upon a POST request to this URL, the endpoint will return a JSON object containing a newly allocated `Id<"_storage">`.
   *
   * The POST URL accepts an optional standard HTTP Digest header with a sha256 checksum.
   *
   * @returns An Effect that yields a URL that allows file upload via an HTTP POST.
   */
  generateUploadUrl(): E.Effect<string, never, never> {
    return E.promise(async () => this.convexStorage.generateUploadUrl())
  }

  /**
   * Delete a file from Convex storage.
   *
   * Once a file is deleted, any URLs previously generated by {@link StorageReader.getUrl} will return 404s.
   *
   * @param storageId - The `Id<"_storage">` of the file to delete from Convex storage.
   * @returns An Effect that completes when the file is successfully deleted.
   */
  delete(storageId: GenericId<"_storage">): E.Effect<void, never, never> {
    return E.promise(async () => this.convexStorage.delete(storageId))
  }
}

/**
 * An interface to read and write files to storage within Convex actions and HTTP actions.
 *
 * Extends StorageWriter with additional Effect-based operations available in the
 * action context, including direct file retrieval and storage.
 */
export class StorageActionWriter extends StorageWriter {
  override convexStorage: ConvexStorageActionWriter

  constructor(convexStorage: ConvexStorageActionWriter) {
    super(convexStorage)
    this.convexStorage = convexStorage
  }

  /**
   * Get a Blob containing the file associated with the provided `Id<"_storage">`.
   *
   * @param storageId - The `Id<"_storage">` of the file to retrieve.
   * @returns An Effect that yields the file Blob if it exists, or fails with
   * FileNotFoundError if the file is not found.
   */
  get(storageId: GenericId<"_storage">): E.Effect<Blob, FileNotFoundError, never> {
    return E.promise(async () => this.convexStorage.get(storageId)).pipe(
      E.flatMap((blob) => {
        if (blob) {
          return E.succeed(blob)
        }

        return E.fail(new FileNotFoundError())
      }),
    )
  }

  /**
   * Store the file contained in the Blob.
   *
   * If provided, this will verify the sha256 checksum matches the contents of the file.
   *
   * @param blob - The file content as a Blob.
   * @param options - Optional configuration including sha256 checksum.
   * @returns An Effect that yields the `Id<"_storage">` of the stored file.
   */
  store(blob: Blob, options?: {sha256?: string}): E.Effect<GenericId<"_storage">, never, never> {
    return E.promise(async () => this.convexStorage.store(blob, options))
  }
}
